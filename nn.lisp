(declaim (optimize (speed 3) (safety 0) (debug 0)))
(defun row (m)
  (declare ((simple-array single-float) m))
  (array-dimension m 0))

(defun col (m)
  (declare ((simple-array single-float) m))
  (array-dimension m 1))

(defun mat-dot (d a b)
  (declare ((simple-array single-float) d a b))
  (dotimes (i (row d))
    (dotimes (j (col d))
      (setf (aref d i j) 0.0)
      (dotimes (k (col a))
        (incf (aref d i j) (* (aref a i k) (aref b k j)))))))

(defun sig (n)
  (declare (single-float n))
  (/ 1.0 (+ 1.0 (exp (- n)))))

(defun mat-sum (d a)
  (declare ((simple-array single-float) d a))
  (dotimes (i (row d))
    (dotimes (j (col d))
      (incf (aref d i j) (aref a i j)))))

(defun mat-sig (a)
  (declare ((simple-array single-float) a))
  (dotimes (i (row a))
    (dotimes (j (col a))
      (setf (aref a i j) (sig (aref a i j))))))

(defun mat-rand (a min max)
  (declare (fixnum min max))
  (declare ((simple-array single-float) a))
  (dotimes (i (array-dimension a 0) a)
    (dotimes (j (array-dimension a 1))
      (setf (aref a i j) (+ (* (random 1.0) (- max min)) min)))))

(defstruct nn-s
  (w nil :type (simple-array (simple-array single-float)))
  (b nil :type (simple-array (simple-array single-float)))
  (a nil :type (simple-array (simple-array single-float))))

(defun get-w (nn i)
  (declare (fixnum i))
  (declare (nn-s nn))
  (aref (nn-s-w nn) i))

(defun get-b (nn i)
  (declare (fixnum i))
  (declare (nn-s nn))
  (aref (nn-s-b nn) i))

(defun get-a (nn i)
  (declare (fixnum i))
  (declare (nn-s nn))
  (aref (nn-s-a nn) i))

(defun add (a b)
  (declare (fixnum a b))
  (the fixnum (+ a b)))

(defun make-nn (arch)
  (let ((nn (make-nn-s :w (make-array (1- (length arch)) :initial-element (make-array 0 :element-type 'single-float) :element-type '(simple-array single-float))
                       :b (make-array (1- (length arch)) :initial-element (make-array 0 :element-type 'single-float) :element-type '(simple-array single-float))
                       :a (make-array (length arch) :initial-element (make-array 0 :element-type 'single-float) :element-type '(simple-array single-float)))))
    (setf (aref (nn-s-a nn) 0) (make-array (list 1 (first arch)) :element-type 'single-float))
    (loop for i from 1 to (1- (length arch))
          do (setf (aref (nn-s-a nn) i) (make-array (list 1 (elt arch i)) :element-type 'single-float))
          do (setf (aref (nn-s-w nn) (1- i)) (make-array (list (col (aref (nn-s-a nn) (1- i))) (elt arch i)) :element-type 'single-float))
          do (setf (aref (nn-s-b nn) (1- i)) (make-array (list 1 (elt arch i)) :element-type 'single-float)))
    nn))

(defun nn-rand (nn min max)
  (declare (fixnum min max))
  (declare (nn-s nn))
  (dotimes (i (array-dimension (nn-s-w nn) 0))
    (mat-rand (aref (nn-s-w nn) i) min max)
    (mat-rand (aref (nn-s-b nn) i) min max)))

(defun nn-forward (nn)
  (declare (nn-s nn))
  (dotimes (i (the fixnum (matrices (nn-s-w nn))))
    (declare (fixnum i))
    (mat-dot (get-a nn (add i 1)) (get-a nn i) (get-w nn i))
    (mat-sum (get-a nn (add i 1)) (get-b nn i))
    (mat-sig (get-a nn (add i 1)))))

(defun square (x)
  (declare (single-float x))
  (* x x))

(defun row-copy (m i)
  (declare (fixnum i))
  (declare ((simple-array single-float) m))
  (let ((c (make-array (list 1 (col m)) :element-type 'single-float)))
    (dotimes (j (col m))
      (setf (aref c 0 j) (aref m i j)))
    c))

(defun matrices (m)
  (declare ((simple-array (simple-array single-float)) m))
  (the fixnum (array-dimension m 0)))

(defun nn-cost (nn mi mo)
  (declare (nn-s nn))
  (declare ((simple-array single-float) mi mo))
  (do ((c 0.0) (i 0 (1+ i)))
      ((>= i (row mi)) (the single-float (/ c (row mi))))
    (declare (single-float c))
    (setf (aref (nn-s-a nn) 0) (row-copy mi i))
    (nn-forward nn)
    (dotimes (j (col mo))
      (incf c (square (- (aref (aref (nn-s-a nn) (1- (matrices (nn-s-a nn)))) 0 j) (aref mo i j)))))))

(defun nn-diff (nn g eps mi mo)
  (declare (nn-s nn))
  (declare (nn-s g))
  (declare ((simple-array single-float) mi mo))
  (declare (single-float eps))
  (let ((c (nn-cost nn mi mo)))
    (dotimes (i (matrices (nn-s-w nn)))
      (dotimes (j (row (get-w nn i)))
        (dotimes (k (col (get-w nn i)))
          (let ((saved (aref (get-w nn i) j k)))
            (incf (aref (get-w nn i) j k) eps)
            (setf (aref (get-w g i) j k) (/ (- (nn-cost nn mi mo) c) eps))
            (setf (aref (get-w nn i) j k) saved))))
      (dotimes (j (row (get-b nn i)))
        (dotimes (k (col (get-b nn i)))
          (let ((saved (aref (get-b nn i) j k)))
            (incf (aref (get-b nn i) j k) eps)
            (setf (aref (get-b g i) j k) (/ ( - (nn-cost nn mi mo) c) eps))
            (setf (aref (get-b nn i) j k) saved)))))))

(defun nn-learn (nn g rate)
  (declare (nn-s nn))
  (declare (nn-s g))
  (declare (single-float rate))
  (dotimes (i (matrices (nn-s-w nn)))
    (dotimes (j (row (get-w nn i)))
      (dotimes (k (col (get-w nn i)))
        (decf (aref (get-w nn i) j k) (* rate (aref (get-w g i) j k)))))
    (dotimes (j (row (get-b nn i)))
      (dotimes (k (col (get-b nn i)))
        (decf (aref (get-b nn i) j k) (* rate (aref (get-b g i) j k)))))))

(defparameter *xor*
  #2A((0.0 0.0 0.0)
      (0.0 1.0 1.0)
      (1.0 0.0 1.0)
      (1.0 1.0 0.0)))

(defparameter *or*
  #2A((0.0 0.0 0.0)
      (0.0 1.0 1.0)
      (1.0 0.0 1.0)
      (1.0 1.0 1.0)))

(defparameter *and*
  #2A((0.0 0.0 0.0)
      (0.0 1.0 0.0)
      (1.0 0.0 0.0)
      (1.0 1.0 1.0)))

(defparameter *nand*
  #2A((0.0 0.0 1.0)
      (0.0 1.0 1.0)
      (1.0 0.0 1.0)
      (1.0 1.0 0.0)))

(defparameter *td* *xor*)

(defun main ()
  (let ((nn (make-nn '(2 2 1)))
        (g (make-nn '(2 2 1)))
        (mi (make-array '(4 2) :element-type 'single-float))
        (mo (make-array '(4 1) :element-type 'single-float))
        (eps 1e-1)
        (rate 1e-1))
    (nn-rand nn 0 1)
    (dotimes (i 4)
      (dotimes (j 2)
        (setf (aref mi i j) (aref *td* i j))))
    (dotimes (i 4)
      (dotimes (j 1)
        (setf (aref mo i j) (aref *td* i (+ 2 j)))))
    (dotimes (i 100000)
      (nn-diff nn g eps mi mo)
      (nn-learn nn g rate)
      (format t "~d: ~d~%" i (nn-cost nn mi mo))
      )
    (print nn)
    (print g)
    (dotimes (i 2)
      (dotimes (j 2)
        (setf (aref (get-a nn 0) 0 0) (* 1.0 i))
        (setf (aref (get-a nn 0) 0 1) (* 1.0 j))
        (nn-forward nn)
        (format t "~%~d ^ ~d = ~d; real = ~d~%" i j (aref (get-a nn (1- (matrices (nn-s-a nn)))) 0 0) (aref mo (+ (* 2 i) j) 0))))
    (print (nn-cost nn mi mo))))

