; (declaim (optimize (speed 3) (safety 0) (debug 0)))
(defun row (m)
  (declare ((simple-array single-float) m))
  (array-dimension m 0))

(defun col (m)
  (declare ((simple-array single-float) m))
  (array-dimension m 1))

(defun mat-dot (d a b)
  (declare ((simple-array single-float) d a b))
  (dotimes (i (row d))
    (dotimes (j (col d))
      (setf (aref d i j) 0.0)
      (dotimes (k (col a))
        (incf (aref d i j) (* (aref a i k) (aref b k j)))))))

(defun sig (n)
  (declare (single-float n))
  (/ 1.0 (+ 1.0 (exp (- n)))))

(defun mat-sum (d a)
  (declare ((simple-array single-float) d a))
  (dotimes (i (row d))
    (dotimes (j (col d))
      (incf (aref d i j) (aref a i j)))))

(defun mat-sig (a)
  (declare ((simple-array single-float) a))
  (dotimes (i (row a))
    (dotimes (j (col a))
      (setf (aref a i j) (sig (aref a i j))))))

(defun mat-rand (a min max)
  (declare (fixnum min max))
  (declare ((simple-array single-float) a))
  (dotimes (i (array-dimension a 0) a)
    (dotimes (j (array-dimension a 1))
      (setf (aref a i j) (+ (* (random 1.0) (- max min)) min)))))

(defstruct nn-s
  (w nil :type (simple-array (simple-array single-float)))
  (b nil :type (simple-array (simple-array single-float)))
  (a nil :type (simple-array (simple-array single-float))))

(defun get-w (nn i)
  (declare (fixnum i))
  (declare (nn-s nn))
  (aref (nn-s-w nn) i))

(defun get-b (nn i)
  (declare (fixnum i))
  (declare (nn-s nn))
  (aref (nn-s-b nn) i))

(defun get-a (nn i)
  (declare (fixnum i))
  (declare (nn-s nn))
  (aref (nn-s-a nn) i))

(defun add (a b)
  (declare (fixnum a b))
  (the fixnum (+ a b)))

(defun make-nn (arch)
  (let ((nn (make-nn-s :w (make-array (1- (length arch)) :initial-element (make-array 0 :element-type 'single-float) :element-type '(simple-array single-float))
                       :b (make-array (1- (length arch)) :initial-element (make-array 0 :element-type 'single-float) :element-type '(simple-array single-float))
                       :a (make-array (length arch) :initial-element (make-array 0 :element-type 'single-float) :element-type '(simple-array single-float)))))
    (setf (aref (nn-s-a nn) 0) (make-array (list 1 (first arch)) :element-type 'single-float))
    (loop for i from 1 to (1- (length arch))
          do (setf (aref (nn-s-a nn) i) (make-array (list 1 (elt arch i)) :element-type 'single-float))
          do (setf (aref (nn-s-w nn) (1- i)) (make-array (list (col (aref (nn-s-a nn) (1- i))) (elt arch i)) :element-type 'single-float))
          do (setf (aref (nn-s-b nn) (1- i)) (make-array (list 1 (elt arch i)) :element-type 'single-float)))
    nn))

(defun nn-rand (nn min max)
  (declare (fixnum min max))
  (declare (nn-s nn))
  (dotimes (i (array-dimension (nn-s-w nn) 0))
    (mat-rand (aref (nn-s-w nn) i) min max)
    (mat-rand (aref (nn-s-b nn) i) min max)))

(defun nn-forward (nn)
  (declare (nn-s nn))
  (dotimes (i (the fixnum (matrices (nn-s-w nn))))
    (declare (fixnum i))
    (mat-dot (get-a nn (add i 1)) (get-a nn i) (get-w nn i))
    (mat-sum (get-a nn (add i 1)) (get-b nn i))
    (mat-sig (get-a nn (add i 1)))))

(defun square (x)
  (declare (single-float x))
  (* x x))

(defun row-copy (m i)
  (declare (fixnum i))
  (declare ((simple-array single-float) m))
  (let ((c (make-array (list 1 (col m)) :element-type 'single-float)))
    (dotimes (j (col m))
      (setf (aref c 0 j) (aref m i j)))
    c))

(defun matrices (m)
  (declare ((simple-array (simple-array single-float)) m))
  (the fixnum (array-dimension m 0)))

(defun nn-cost (nn ti to)
  (declare (nn-s nn))
  (declare ((simple-array single-float) ti to))
  (do ((c 0.0) (i 0 (1+ i)))
      ((>= i (row ti)) (the single-float (/ c (row ti))))
    (declare (single-float c))
    (setf (aref (nn-s-a nn) 0) (row-copy ti i))
    (nn-forward nn)
    (dotimes (j (col to))
      (incf c (square (- (aref (aref (nn-s-a nn) (1- (matrices (nn-s-a nn)))) 0 j) (aref to i j)))))))
(defun mat-zero (m)
  (declare ((simple-array single-float) m))
  (dotimes (j (row m))
    (dotimes (k (col m))
      (setf (aref m j k) 0.0))))
 
(defun nn-zero (nn)
  (declare (nn-s nn))
  (dotimes (i (matrices (nn-s-w nn)))
    (mat-zero (aref (nn-s-w nn) i))
    (mat-zero (aref (nn-s-b nn) i))
    (mat-zero (aref (nn-s-a nn) i)))
  (mat-zero (aref (nn-s-a nn) (1- (matrices (nn-s-a nn))))))

(defmacro nn-output (nn)
  `(get-a ,nn (1- (matrices (nn-s-a ,nn)))))
(defmacro nn-count (nn)
  `(matrices (nn-s-w ,nn)))

(defun nn-backprop (nn g ti to)
  (declare (nn-s nn))
  (declare (nn-s g))
  (declare ((simple-array single-float) ti to))
  (nn-zero g)
  (dotimes (i (row ti))
    (setf (aref (nn-s-a nn) 0) (row-copy ti i))
    (nn-forward nn)
    (dotimes (j (matrices (nn-s-a nn)))
      (mat-zero (aref (nn-s-a g) j)))
    (dotimes (j (col to))
      (setf (aref (nn-output g) 0 j) (- (aref (nn-output nn) 0 j) (aref to i j))))
    (loop for l from (nn-count nn) downto 1
          do (dotimes (j (col (get-a nn l)))
               (let ((a (aref (get-a nn l) 0 j))
                     (da (aref (get-a g l) 0 j)))
                 (incf (aref (get-b g (1- l)) 0 j) (* 2 da a (- 1 a)))
                 (dotimes (k (col (get-a nn (1- l))))
                   (let ((pa (aref (get-a nn (1- l)) 0 k))
                         (w (aref (get-w nn (1- l)) k j)))
                     (incf (aref (get-w g (1- l)) k j) (* 2 da a (- 1 a) pa))
                     (incf (aref (get-a g (1- l)) 0 k) (* 2 da a (- 1 a) w))))))))
  (dotimes (i (nn-count g))
    (dotimes (j (row (get-w g i)))
      (dotimes (k (col (get-w g i)))
        (setf (aref (get-w g i) j k) (/ (aref (get-w g i) j k) (row ti)))))
    (dotimes (j (row (get-b g i)))
      (dotimes (k (col (get-b g i)))
        (setf (aref (get-b g i) j k) (/ (aref (get-b g i) j k) (row ti)))))))

(defun nn-diff (nn g eps ti to)
  (declare (nn-s nn))
  (declare (nn-s g))
  (declare ((simple-array single-float) ti to))
  (declare (single-float eps))
  (let ((c (nn-cost nn ti to)))
    (dotimes (i (matrices (nn-s-w nn)))
      (dotimes (j (row (get-w nn i)))
        (dotimes (k (col (get-w nn i)))
          (let ((saved (aref (get-w nn i) j k)))
            (incf (aref (get-w nn i) j k) eps)
            (setf (aref (get-w g i) j k) (/ (- (nn-cost nn ti to) c) eps))
            (setf (aref (get-w nn i) j k) saved))))
      (dotimes (j (row (get-b nn i)))
        (dotimes (k (col (get-b nn i)))
          (let ((saved (aref (get-b nn i) j k)))
            (incf (aref (get-b nn i) j k) eps)
            (setf (aref (get-b g i) j k) (/ ( - (nn-cost nn ti to) c) eps))
            (setf (aref (get-b nn i) j k) saved)))))))

(defun nn-learn (nn g rate)
  (declare (nn-s nn))
  (declare (nn-s g))
  (declare (single-float rate))
  (dotimes (i (matrices (nn-s-w nn)))
    (dotimes (j (row (get-w nn i)))
      (dotimes (k (col (get-w nn i)))
        (decf (aref (get-w nn i) j k) (* rate (aref (get-w g i) j k)))))
    (dotimes (j (row (get-b nn i)))
      (dotimes (k (col (get-b nn i)))
        (decf (aref (get-b nn i) j k) (* rate (aref (get-b g i) j k)))))))

