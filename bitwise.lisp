; (declaim (optimize (speed 3) (safety 0) (debug 0)))
(defparameter *xor*
  #2A((0.0 0.0 0.0)
      (0.0 1.0 1.0)
      (1.0 0.0 1.0)
      (1.0 1.0 0.0)))

(defparameter *or*
  #2A((0.0 0.0 0.0)
      (0.0 1.0 1.0)
      (1.0 0.0 1.0)
      (1.0 1.0 1.0)))

(defparameter *and*
  #2A((0.0 0.0 0.0)
      (0.0 1.0 0.0)
      (1.0 0.0 0.0)
      (1.0 1.0 1.0)))

(defparameter *nand*
  #2A((0.0 0.0 1.0)
      (0.0 1.0 1.0)
      (1.0 0.0 1.0)
      (1.0 1.0 0.0)))

(defparameter *td* *xor*)

(defun main ()
  (let ((nn (make-nn '(2 2 1)))
        (g (make-nn '(2 2 1)))
        (mi (make-array '(4 2) :element-type 'single-float))
        (mo (make-array '(4 1) :element-type 'single-float))
        (rate 1.0))
    (nn-rand nn 0 1)
    (dotimes (i 4)
      (dotimes (j 2)
        (setf (aref mi i j) (aref *td* i j))))
    (dotimes (i 4)
      (dotimes (j 1)
        (setf (aref mo i j) (aref *td* i (+ 2 j)))))
    (dotimes (i 5000)
      (nn-backprop nn g mi mo)
      (nn-learn nn g rate)
      (format t "~%~d: ~d~%" i (nn-cost nn mi mo))
      )
    (print nn)
    (print g)
    (dotimes (i 2)
      (dotimes (j 2)
        (setf (aref (get-a nn 0) 0 0) (* 1.0 i))
        (setf (aref (get-a nn 0) 0 1) (* 1.0 j))
        (nn-forward nn)
        (format t "~%~d ^ ~d = ~d; real = ~d~%" i j (aref (get-a nn (1- (matrices (nn-s-a nn)))) 0 0) (aref mo (+ (* 2 i) j) 0))))
    (print (nn-cost nn mi mo))))
